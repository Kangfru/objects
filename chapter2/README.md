## Chapter 2. 객체지향 프로그래밍
### 1. 영화 예매 시스템
객체지향 프로그래밍을 설명하기 위해 영화 예매 시스템을 개발한다고 가정해보자. 이에 따른 요구 사항은 아래와 같다. <br />
a. 특정한 조건을 만족하는 예매자는 요금을 할인받을 수 있다.
 - 할인액을 결정하는 두 가지 규칙은 할인 조건과 할인 정책이다.
 - 할인 조건은 순서 조건과 기간 조건이 있으며 순서 조건은 조건이 10일 경우 매일 10번째 상영되는 영화에 할인혜택을 제공한다.
 - 기간 조건은 요일, 시작 시간, 종료 시간의 세 파트로 나눠져 있으며 영화 시작 시간이 해당 기간 안에 포함될 경우 할인한다.
 - 할인 정책은 할인 요금을 결정한다.
 - 할인 정책에는 금액 할인 정책과 비율 할인 정책이 있으며, 금액 할인은 정해진 금액만큼 할인해주는 방식이며, 비율 할인 정책은 정해진 비율만큼 할인한다.

b. 영화 별로 하나의 할인 정책만 할당할 수 있다.
 - 할인 정책을 지정하지 않는 것도 가능하다.
 - 할인 조건은 다수의 할인 조건을 함께 지정할 수 있다.

### 2. 객체지향 프로그래밍을 향해
진정한 객체지향 패러다임은 클래스가 아닌 객체에 초점을 맞출 때에 얻을 수 있다.
 - 어떤 클래스가 필요한 지를 고민하기 전에 어떤 객체들이 필요한지 고민하라.
 - 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야 한다.

도메인은 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 도메인이라고 부른다. 객체지향 패러다임이 강력한 이유는 요구사항을 분석하는 초기 단계부터 <br />
객체까지 동일한 추상화 기법을 사용할 수 있기 때문이다. 그렇기에 도메인을 구성하는 개념들이 객체와 클래스로 매끄럽게 연결될 수 있다.

a. 자율적인 객체 <br />
 - 객체는 상태와 행동을 함꼐 가지는 복합적인 존재이다.
 - 객체는 스스로 판단하고 행동하는 자율적인 존재이다.
 - 과거와 달리 객체 단위 안에 데이터와 기능을 한 덩어리로 묶음으로써 문제 영역의 아이디어를 적절하게 표현할 수 있게 했다. 이를 캡슐화라 한다. 

b. 협력
 - 객체는 다른 객체의 인터페이스에 공개된 행동을 수행하도록 요청하며, 요청을 받은 객체는 자율적인 방법에 따라 요청을 처리한 후 응답한다.
 - 객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 메시지를 전송하는 것 뿐이다.
 - 메시지를 수신한 객체는 메시지를 처리하기 위한 자신만의 방법을 가지고 있는데, 이를 메서드라고 부른다.
 - 메시지와 메서드를 구분하는 것은 다형성의 개념을 이해하는데 큰 도움이 된다.

c. 의존성
 - Movie 클래스 내부에선 DiscountPolicy에만 의존하도록 되어 있으나. 실행 시점에는 각 AmountDiscountPolicy, PercentDiscountPolicy의 인스턴스에 의존한다.
 - 이를 런타임 의존성이라고 하며, 코드의 의존성과 실행 시점의 의존성이 서로 다를 수 있다.
 - 코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드는 이해하기 어려워진다. 코드를 이해하기 위해서는 코드뿐만 아니라 객체를 생성하고 연결하는 부분을 찾아야 하기 때문.
 - 반면 코드의 의존성과 실행 시점의 의존성이 다르면 다를 수록 코드는 더 유연해지고 확장 가능해진다. 이같은 의존성의 양면성은 설계가 트레이드 오프의 산물이라는 사실을 잘 보여준다.
 - 설계가 유연해질수록 코드를 이해하고 디버깅하기는 점점 더 어려워진다. 반대로 유연성을 억제하면 디버깅은 쉬워지지만 재사용성과 확장 가능성은 낮아진다.

d. 상속
 - 상속은 객체지향에서 코드를 재사용하기 위해 가장 널리 사용되는 방법이다.
 - 상속을 이용해 기존 클래스의 속성과 행동을 포함시킬 수 있다.
 - DiscountPolicy <- AmountDiscountPolicy, PercentDiscountPolicy 는 이 점을 잘 보여준다. 
 - 상속이 가치있는 것은 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을 수 있기 때문이다.
 - 인터페이스는 객체가 이해할 수 있는 메시지의 목록을 정의한다. 상속을 통해 자식 클래스는 자신의 인터페이스에 부모 클래스의 인터페이스를 포함한다.
 - 결과적으로 자식 클래스는 부모 클래스가 수신할 수 있는 모든 메시지를 수신할 수 있기 때문에 외부 객체는 자식 클래스와 부모 클래스를 동일한 타입으로 간주할 수 있다.
 - Movie 입장에서는 자신과 협력하는 객체가 어떤 클래스의 인스턴스인 지 알 필요 없이 calculateDiscountAmount 메시지를 수신할 수 있다는 사실만이 중요하다.
 - 이처럼 자식 클래스가 부모 클래스를 대신하는 것을 업캐스팅이라고 한다.

e. 다형성
 - 예시에서 Movie는 DiscountPolicy 클래스에 메시지를 전송하지만 실행되는 시점에 어떤 메서드가 실행될 것인 지는 메시지를 수신하는 클래스가 무엇이냐에 따라 달렸다.
 - 이를 다형성이라고 한다.
 - 다형성이란 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력을 의미한다.
 - 다형적인 협력에 참여하는 객체들은 모두 같은 메시지를 이해할 수 있어야 한다(인터페이스가 동일해야 한다.)
---
결론은 간단하다. 유연성이 필요한 곳에 추상화를 사용해야 한다.

### 3. 상속의 단점
 - 상속은 두 가지 관점에서 설계에 안 좋은 영향을 미친다.
 - 하나는 상속이 캡슐화를 위반한다는 것이다.
 - 상속을 이용하기 위해서는 부모 클래스의 내부 구조를 알고 있어야 한다. AmountDiscountMovie와 PercentDiscountMovie를 구현하는 개발자는 부모 클래스인 Movie의 calculateMovieFee 메서드 안에서 getDiscountAMount 메서드를 호출한다는 사실을 알고 있어야 한다.
 - 결과적으로 부모 클래스의 구현이 자식 클래스에게 노출되기 때문에 캡슐화가 약화되며, 자식 클래스가 부모 클래스에 강결합 된다.
 - 이로 인해 부모 클래스를 변경할 때 자식 클래스도 함꼐 변경해야될 확률을 높인다.
 - 두 번째 단점은 설계가 유연하지 않다는 것.
 - 예를 들어 AmountDiscountPolicy를 PercentDiscountPolicy로 바꾼다고 가정하면, 사용되는 인스턴스 자체를 변경해야 한다.
 - 이를 해결하기 위해 합성을 사용한다. 합성이란 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법을 말한다. (Movie의 인스턴스 변수 및 changeDiscountPolicy 참조)
 - 